[
    {
        "code_start_timestamp": 233.33333333333334,
        "code_end_timestamp": 340.0,
        "code_text": "array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]\nfor i in range(len(array)):\n    min_index = i\n    for j in range(i + 1, len(array)):\n        if array[min_index] > array[j]:\n            min_index = j\n    array[i], array[min_index] = array[min_index], array[i]\nprint(array)\n",
        "related_speech_texts": [
            "먼저 파이썬으로 작성한 선택 정렬 코드를 확인해 보겠습니다.",
            "자 이와 같이 아까 확인했던 데이터가 그대로 리스트에 담겨서",
            "저장되어 있는 걸 확인할 수 있고요.",
            "먼저 이 i 값은 0부터 데이터의 개수 minus 1까지 반복을 합니다.",
            "이 i는 가장 작은 데이터와 위치가 바뀔 인덱스를 의미하는 겁니다.",
            "그래서 결과적으로 이 i는 매번 앞쪽으로 보내고자 하는",
            "가장 앞쪽 원소의 위치라고 보시면 되겠습니다.",
            "자 그래서 반복할 때마다 매번 가장 작은 원소의 인덱스를 고를 수 있도록 합니다.",
            "이와 같이 min_index 라고 해서 가장 작은 원소가 존재하는 인덱스의 값을 담을 수 있도록 하고요.",
            "일단 이렇게 처음에는 가장 앞쪽 원소가 가장 작은 원소가 될 수 있도록 합니다.",
            "이제 이어서 이 j는 i 플러스 1부터 전체 원소의 개수 minus 1까지 차례대로 증가하며",
            "선형 탐색을 수행해서 가장 작은 원소를 찾는 겁니다.",
            "자 그래서 현재 가장 작은 원소보다 더 작은 원소가 있다면 그 위치 인덱스 값이",
            "min_index의 값으로 담길 수 있도록 합니다.",
            "결과적으로 이 안쪽에 있는 반복문이 수행이 끝났을 때 가장 작은 원소의 인덱스가",
            "이 min_index에 담기게 될 겁니다.",
            "자 그래서 가장 앞쪽 원소와 가장 작은 원소를 서로 바꿔줄 수 있도록 하는 겁니다.",
            "즉 그 위치가 바뀌도록 하는 걸 확인할 수 있고요.",
            "파이썬에서는 이와 같이 간단히 두 원소의 위치를 바꾸는 swap 연산을 이렇게 한 줄로 간단히 표현할 수 있습니다.",
            "별도의 표준 라이브러리를 호출하지 않고도 이처럼 단순하게 한 줄을 이용해서 바로 swap을 수행할 수 있다는 점이",
            "또 특징이라고 할 수 있는데요.",
            "그래서 결과적으로 이 코드를 실행한 결과는 0부터 9까지 차례대로 정렬된 결과라고 볼 수 있습니다.",
            "이어서 C++로도 다음과 같이 선택 정렬을 구현할 수 있는데요."
        ],
        "topic": "선택 정렬 (Selection Sort) - 파이썬 구현"
    },
    {
        "code_start_timestamp": 340.0,
        "code_end_timestamp": 386.6666666666667,
        "code_text": "#include <bits/stdc++.h>\nusing namespace std;\nint n = 10;\nint target[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\nint main(void) {\n    for (int i = 0; i < n; i++) {\n        int min_index = i;\n        for (int j = i + 1; j < n; j++) {\n            if (target[min_index] > target[j]) {\n                min_index = j;\n            }\n        }\n        swap(target[i], target[min_index]);\n    }\n    for (int i = 0; i < n; i++) {\n        cout << target[i] << ' ';\n    }\n    return 0;\n}\n",
        "related_speech_texts": [
            "이어서 C++로도 다음과 같이 선택 정렬을 구현할 수 있는데요.",
            "자 데이터의 개수가 10개고 이제 10개의 데이터가 차례대로 이렇게 아까와 동일하게 존재하는 것을 확인할 수 있습니다.",
            "그래서 정렬을 수행하는 로직은 앞서 파이썬 코드로 확인했던 내용과 정확히 일치하는 걸 확인할 수 있습니다.",
            "그래서 매번 가장 앞쪽 위치를 이 i라고 하고 현재의 범위에서 가장 작은 원소의 인덱스가",
            "min_index에 담기도록 해서 가장 작은 원소의 위치를 찾은 뒤에 가장 앞쪽에 있는 원소와 가장 작은 원소의 그 위치 값을 서로 바꿔줄 수 있도록 하는 것입니다.",
            "그래서 결과적으로 정렬이 수행된 결과를 출력하면 마찬가지로 0,1,2,3,4,5,6,7,8,9가 출력됩니다.",
            "이어서 자바 코드까지 확인해 보겠습니다. 마찬가지로 배열을 이용해서 총 10개의 데이터가 담길 수 있도록 했고요."
        ],
        "topic": "선택 정렬 (Selection Sort) - C++ 구현"
    },
    {
        "code_start_timestamp": 386.6666666666667,
        "code_end_timestamp": 436.3333333333334,
        "code_text": "public class Main {\n    public static void main(String[] args) {\n        int n = 10;\n        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\n        for (int i = 0; i < n; i++) {\n            int min_index = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[min_index] > arr[j]) {\n                    min_index = j;\n                }\n            }\n            int temp = arr[i];\n            arr[i] = arr[min_index];\n            arr[min_index] = temp;\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
        "related_speech_texts": [
            "이어서 자바 코드까지 확인해 보겠습니다. 마찬가지로 배열을 이용해서 총 10개의 데이터가 담길 수 있도록 했고요.",
            "i는 매번 가장 앞쪽 원소의 인덱스가 되겠고요.",
            "이 min_index를 이용해서 현재의 가장 작은 원소의 인덱스를 찾도록 해서 가장 앞에 있는 원소와 가장 작은 원소의 위치를 서로 바꿔주는 걸 확인할 수 있습니다.",
            "다만 자바에서는 별도로 포인터 연산을 지원하지 않기 때문에 이처럼 세 줄에 걸쳐서 먼저 temp라는 변수에 잠시 하나의 값을 기록해 놓는 방법을 이용해서 두 원소의 위치 값을 바꿔줄 수 있습니다.",
            "그래서 이와 같이 세 줄에 걸쳐서 swap 연산을 수행한 걸 확인할 수 있고요.",
            "결과적으로 정렬이 수행된 결과까지 이렇게 출력해 보시면 앞서 파이썬과 C++의 코드와 마찬가지로 정렬이 수행된 결과가 성공적으로 출력되는 걸 확인할 수 있습니다.",
            "이러한 선택 정렬의 시간 복잡도는 어떻게 될까요?",
            "선택 정렬은 n번만큼 매번 가장 작은 원소를 찾아서 맨 앞으로 보내야 합니다.",
            "그래서 구현 방식에 따라 사소한 차이는 있을 수 있지만 전체 연산 횟수는 이와 같이 n(n-1)/2 이런 식으로 가서 가장 마지막 원소는 정렬을 수행해 주지 않아도 괜찮기 때문에 이와 같이 플러스 1까지 등차 수열 형태로 연산 횟수가 구성되는 걸 확인할 수 있습니다.",
            "그래서 이를 등차 수열 공식에 따라서 이와 같이 변할 수 있는데요.",
            "이러한 연산 횟수에 대한 공식이 빅오 표기법에 따라서 나타내어지면 이 개수에 해당하는 1/2은 그냥 생략되고 또한 가장 차수가 높은 항만 고려하기 때문에 단순히 O(n^2)이라고 변할 수 있습니다.",
            "그래서 이러한 선택 정렬 알고리즘의 시간 복잡도는 O(n^2)입니다.",
            "이어서 삽입 정렬 알고리즘에 대해 알아보겠습니다.",
            "삽입 정렬은 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입하는 방식으로 동작합니다.",
            "데이터를 하나씩 확인하면서 이 데이터는 어느 위치에 들어가는 게 맞을 것인가 그것을 매번 계산해서 적절한 위치에 들어갈 수 있도록 해주는 거죠.",
            "이러한 삽입 정렬은 선택 정렬에 비해서 구현 난이도가 조금 더 높은 편이지만 일반적으로 선택 정렬에 비해서 더 빠르게 동작합니다.",
            "앞선 예시와 마찬가지로 총 10개의 데이터가 있고 10개의 데이터를 정렬한다고 해보겠습니다.",
            "먼저 이러한 삽입 정렬은 앞쪽에 있는 원소들이 이미 정렬 되어있다고 가정하고",
            "이 뒤쪽에 있는 원소를 앞쪽에 있는 원소의 위치 중에서 한 곳으로 들어가도록 만드는 방식으로 동작합니다.",
            "자 그래서 첫 번째 데이터인 7은 그 자체로 정렬 되어있다고 판단하고",
            "이 두 번째 데이터인 5가 어떤 위치로 들어갈지를 판단할 수 있는데요.",
            "이때 이 7의 왼쪽으로 들어가거나 혹은 오른쪽으로 들어가거나 두 가지 경우만 존재하겠죠.",
            "그래서 왼쪽 원소와 비교해서 왼쪽 원소보다 더 작다면 이렇게 왼쪽으로 갈 수 있도록 설정할 수 있습니다.",
            "우리는 기본적으로 정렬 알고리즘에 대해서 다를 때",
            "오름차순 정렬을 수행한다고 가정하고 과정을 살펴보고 있기 때문에",
            "이렇게 왼쪽에 있는 데이터와 비교해서 값이 더 작다면 이렇게 왼쪽 위치로 들어갈 수 있도록 하면 되겠죠.",
            "그래서 결과적으로 7의 왼쪽으로 데이터 5가 들어갈 수 있도록 위치를 바꿔주면 됩니다.",
            "이어서 그 다음 데이터인 9가 어떤 위치로 들어갈지 판단하면 되겠죠.",
            "이제 첫 번째 위치, 두 번째 위치, 세 번째 위치 중에서 한 곳을 고르면 됩니다.",
            "마찬가지로 이 9는 차례대로 왼쪽에 있는 데이터와 비교해서",
            "왼쪽 데이터보다 더 작다면 위치를 바꿔주고 그렇지 않다면 그냥 그 자리에 머물도록 하면 됩니다.",
            "확인해 보시면 이와 같이 7보다 값이 더 크기 때문에 그 자리에 멈춰 있을 수 있도록 현재 위치 그대로 내버려두면 되겠습니다.",
            "마찬가지로 그 다음 데이터인 0을 기준으로 해서 어떤 위치로 들어갈지를 고르면 되는데요.",
            "이때 이 0은 9보다 작고 그 다음에 7보다도 작고 이어서 5와 비교했을 때에도 더 작기 때문에 이 5의 왼쪽까지 쭉 들어가게 됩니다.",
            "즉 매번 위치를 바꿔가면서 가장 첫 번째 위치까지 들어갈 수 있도록 하는 거예요.",
            "이 데이터 0은 매번 왼쪽에 있는 데이터와 그 위치를 바꿔가면서 이동을 하면서 가장 왼쪽 위치로 즉 첫 번째 원소가 될 수 있도록 들어가는 것입니다.",
            "마찬가지로 3도 이렇게 원소의 위치를 바꿔가면서 결과적으로 이 위치, 두 번째 원소의 위치가 되었을 때 멈추겠네요.",
            "이러한 과정을 반복하게 되면 다음과 같이 전체 원소에 대해서 정렬이 수행됩니다.",
            "먼저 삽입 정렬을 파이썬으로 구현한 코드부터 확인해 보겠습니다."
        ],
        "topic": "선택 정렬 (Selection Sort) - 자바 구현"
    },
    {
        "code_start_timestamp": 663.3333333333334,
        "code_end_timestamp": 760.0,
        "code_text": "array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]\nfor i in range(1, len(array)):\n    for j in range(i, 0, -1):\n        if array[j] < array[j - 1]:\n            array[j], array[j - 1] = array[j - 1], array[j]\n        else:\n            break\nprint(array)\n",
        "related_speech_texts": [
            "먼저 삽입 정렬을 파이썬으로 구현한 코드부터 확인해 보겠습니다.",
            "이처럼 총 10개의 데이터가 그대로 들어가 있는 걸 확인할 수 있고요.",
            "이제 이 두 번째 원소부터 시작을 해서 왼쪽으로 이동해 나가면서 위치를 바꿔주는 방법을 이용하는 걸 확인할 수 있습니다.",
            "이 j는 특정 범위를 반복할 건데 여기에서 range 함수 안에 이렇게 3개의 인자가 들어가는 경우 이 세 번째는 step을 의미합니다.",
            "즉 i부터 출발해서 1까지 1씩 감소하면서 반복을 하는 겁니다.",
            "반복할 때마다 j는 현재 삽입하고자 하는 원소의 위치를 의미합니다.",
            "왼쪽에 있는 데이터와 비교했을 때 자기가 더 값이 작다면 위치를 바꿔주면 되겠죠.",
            "이렇게 swap 연산을 수행하는 걸 확인할 수 있고요.",
            "만약에 현재 확인하고 있는 데이터가 왼쪽에 있는 원소보다 크거나 같다면 그 위치에서 멈추면 될 겁니다.",
            "이렇게 else 부분에는 바로 break문이 들어가는 걸 확인할 수 있습니다.",
            "자기보다 작은 데이터를 만났을 때 그 위치에서 멈출 수 있도록 하는 걸 확인할 수 있고요.",
            "결과적으로 두 번째 데이터부터 마지막 데이터까지 하나씩 확인하면서",
            "어떤 위치에 들어갈지를 안쪽에 있는 반복문을 이용해서 찾을 수 있는 겁니다.",
            "매번 왼쪽에 있는 원소와 비교해서 만약 자기가 더 작다면 바로 왼쪽에 있는 원소와 위치를 바꿔주는 방법을 이용함으로써 결과적으로 해당 원소가 어떤 위치에서 멈추면 되는지를",
            "매번 설정해 줌으로써 삽입 정렬을 수행하는 걸 확인할 수 있습니다.",
            "실행 결과 0부터 9까지 각 데이터가 차례대로 정렬되는 걸 확인할 수 있습니다.",
            "마찬가지로 C++에서도 동일한 로직을 이용해서 코드를 구현할 수 있는데요."
        ],
        "topic": "삽입 정렬 (Insertion Sort) - 파이썬 구현"
    },
    {
        "code_start_timestamp": 760.0,
        "code_end_timestamp": 786.6666666666666,
        "code_text": "#include <bits/stdc++.h>\nusing namespace std;\nint n = 10;\nint target[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\nint main(void) {\n    for (int i = 1; i < n; i++) {\n        for (int j = i; j > 0; j--) {\n            if (target[j] < target[j - 1]) {\n                swap(target[j], target[j - 1]);\n            }\n            else break;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cout << target[i] << ' ';\n    }\n    return 0;\n}\n",
        "related_speech_texts": [
            "마찬가지로 C++에서도 동일한 로직을 이용해서 코드를 구현할 수 있는데요.",
            "문법만 다르고 파이썬 코드와 정확히 동일한 로직을 이용해서 구현되어 있는 걸 확인할 수 있습니다.",
            "두 번째 원소부터 마지막 원소까지 각 원소는 매번 더 이상 이동할 수 없을 때까지 왼쪽 데이터와 위치를 바꿔가면서 왼쪽으로 이동시켜주면 되는 겁니다.",
            "이처럼 삽입 정렬을 작성할 수가 있습니다.",
            "실행 결과는 동일하고요.",
            "이어서 자바로 구현한 삽입 정렬은 다음과 같습니다."
        ],
        "topic": "삽입 정렬 (Insertion Sort) - C++ 구현"
    },
    {
        "code_start_timestamp": 786.6666666666666,
        "code_end_timestamp": 825.0,
        "code_text": "public class Main {\n    public static void main(String[] args) {\n        int n = 10;\n        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j > 0; j--) {\n                if (arr[j] < arr[j - 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j - 1];\n                    arr[j - 1] = temp;\n                }\n                else break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
        "related_speech_texts": [
            "이어서 자바로 구현한 삽입 정렬은 다음과 같습니다.",
            "두 번째 원소부터 마지막 원소까지 각 원소에 대해서 해당 원소가 들어갈 위치를 찾는 건데요.",
            "마찬가지로 왼쪽 데이터와 비교해서 왼쪽에 있는 데이터보다 자기가 더 작다면 바로 왼쪽 원소와 위치를 바꿔주는 걸 확인할 수 있습니다.",
            "자바에서는 포인터와 같은 기능을 제공하지 않으며 별도로 표준 라이브러리 단에서 swap 연산을 제공하지 않기 때문에 이와 같이 세 줄에 걸쳐서 두 원소의 위치를 바꿔줄 수 있습니다.",
            "정렬된 결과를 출력하면 앞서 다루었던 두 코드와 정확히 동일한 결과가 나오는 걸 확인할 수 있습니다.",
            "삽입 정렬의 시간 복잡도는 O(n^2)입니다.",
            "직관적으로 시간 복잡도를 판단했을 때 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용되었다는 점에서 O(n^2)이 걸릴 것이라고 예상할 수 있죠.",
            "물론 이중 반복문이 사용된다고 해서 반드시 O(n^2)인 것은 아닙니다.",
            "만약 반복문 안에 별도의 함수가 추가적으로 호출된다면 그 함수의 시간 복잡도까지 고려할 필요가 있습니다.",
            "삽입 정렬의 예시는 단순히 이중 반복문 안에서 비교 연산과 swap 연산이 수행되기 때문에 전체 시간 복잡도를 O(n^2)이라고 말할 수 있습니다.",
            "특히 삽입 정렬은 현재 리스트의 데이터가 거의 정렬 되어 있는 상태라면 매우 빠르게 동작한다는 점이 특징입니다.",
            "최선의 경우 즉 이미 모든 데이터가 다 정렬 되어 있다고 하면 이때는 O(n)만큼의 시간 복잡도를 가집니다.",
            "한 번 이렇게 이미 0부터 9까지의 데이터가 다 정렬 되어 있다고 했을 때 여기에서 삽입 정렬을 수행하면 어떻게 될까요.",
            "이때 이 두 번째 원소부터 시작하겠죠.",
            "두 번째 원소인 1이 들어갈 위치를 고르는 데 왼쪽 원소보다 크기 때문에 바로 그 위치에서 멈추면 됩니다.",
            "이와 같이 각 데이터가 이미 정렬되어 있는 경우 삽입 정렬은 상수 시간에 가깝게 동작할 수 있습니다.",
            "퀵 정렬에 대해서 알아보겠습니다.",
            "퀵 정렬은 이름에서부터 알 수 있듯이 매우 빠른 정렬 알고리즘 중 하나입니다.",
            "일반적으로 데이터의 특성과 관계없이 표준적으로 사용할 수 있는 정렬 알고리즘입니다.",
            "퀵 정렬의 핵심 동작 원리는 다음과 같습니다.",
            "먼저 기준 데이터를 고른 뒤 그 기준보다 큰 데이터와 작은 데이터의 위치를 서로 바꾸는 방법입니다.",
            "일반적으로 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.",
            "특히 병합 정렬과 더불어 대부분의 프로그래밍 언어에서 표준 정렬 라이브러리에 근간이 되는 알고리즘입니다.",
            "대표적으로 C, Java, Python의 표준 정렬 라이브러리도 모두 퀵 정렬 또는 병합 정렬의 아이디어를 채택한 하이브리드 방식의 정렬 알고리즘을 사용하고 있습니다.",
            "이 정도로 퀵 정렬은 병합 정렬과 더불어 일반적인 상황에서 가장 많이 사용되는 대표적인 정렬 알고리즘입니다.",
            "이번 시간에는 퀵 정렬에 대해서 알아보겠습니다.",
            "퀵 정렬은 정렬을 수행하는 과정에서 기준 데이터, 즉 pivot 값을 설정한 뒤에 정렬을 수행합니다.",
            "가장 기본적인 형태의 퀵 정렬은 단순히 첫 번째 데이터를 기준 데이터로 설정하는 방식으로 동작합니다.",
            "예시를 통해 퀵 정렬의 동작 과정을 확인해 보겠습니다.",
            "총 10개의 데이터가 존재한다고 가정해 보겠습니다.",
            "여기에서 퀵 정렬을 수행할 때 첫 번째 원소를 기준 즉 pivot으로 설정해서 정렬을 수행합니다.",
            "현재 pivot 값은 5입니다.",
            "퀵 정렬을 수행할 때는 왼쪽에서부터 pivot 값보다 큰 데이터를 고르고 오른쪽에서부터는 pivot 값보다 작은 데이터를 고릅니다.",
            "이와 같이 왼쪽에서부터 pivot 값보다 큰 값인 7이 선택됩니다.",
            "오른쪽에서부터 pivot 값보다 작은 값인 4가 선택됩니다.",
            "이 7과 4의 위치를 서로 바꿔줍니다.",
            "다시 한 번 pivot 값을 기준으로 해서 더 큰 데이터를 고르고 오른쪽에서 더 작은 데이터를 골라서 9와 2가 선택됩니다.",
            "이 9와 2도 서로 위치를 바꿔줍니다.",
            "이처럼 다시 한 번 pivot 값을 기준으로 해서 더 큰 데이터를 왼쪽에서 고르고 오른쪽에서 더 작은 데이터를 골라서 서로 위치를 바꿔줍니다.",
            "엇갈린 상황에서는 작은 데이터와 pivot 값을 서로 바꿔줍니다.",
            "pivot 값의 위치가 중간으로 들어가게 되고 데이터가 왼쪽과 오른쪽으로 분할됩니다.",
            "이 분할을 partition이라고도 합니다.",
            "이어서 왼쪽 데이터와 오른쪽 데이터들을 각각 하나의 배열로 간단히 나눠서 pivot 값을 이용해 다시 한 번 정렬을 수행합니다.",
            "이렇게 재귀적으로 정렬을 수행합니다.",
            "이 과정은 데이터의 범위가 점점 좁아지는 형태로 동작합니다.",
            "왼쪽 데이터에 대해서도 정렬을 수행하면 pivot 값 기준으로 왼쪽과 오른쪽으로 분할됩니다.",
            "이러한 퀵 정렬을 수행하는 과정을 재귀적으로 계속해서 수행하면 전체 데이터에 대해 정렬이 완료됩니다.",
            "퀵 정렬은 왜 빠르게 동작할까요?",
            "이상적인 경우 한 번 partition을 수행할 때마다 데이터의 범위를 절반으로 나눌 수 있다면 전체 연산의 수는 O(n log n)입니다.",
            "전체 데이터에 대해서 퀵 정렬을 수행해서 데이터가 반반씩 분할된다고 가정해 보겠습니다.",
            "실제로는 pivot 값을 기준으로 왼쪽과 오른쪽으로 분할이 이루어집니다.",
            "데이터가 절반씩 나누어지는 경우 전체 연산의 수는 O(log n)입니다.",
            "퀵 정렬의 시간 복잡도는 O(n log n)입니다.",
            "수학적으로 증명된 내용이며 이 교재에서는 증명 과정을 생략했습니다.",
            "퀵 정렬의 최악의 경우 시간 복잡도는 O(n^2)입니다.",
            "pivot 값을 어떻게 설정하느냐에 따라 분할이 절반에 가깝게 이루어지지 않고 한쪽으로 편향될 수 있기 때문입니다.",
            "다음과 같은 예시를 확인해 보겠습니다.",
            "첫 번째 원소를 pivot으로 선택했을 때 이미 정렬된 배열에 대해 퀵 정렬을 수행하면 어떻게 될까요?",
            "첫 번째 원소인 0을 pivot으로 설정합니다.",
            "왼쪽에서부터 큰 데이터를 찾으면 1이 선택됩니다.",
            "오른쪽에서 작은 데이터를 찾을 수 없기 때문에 pivot 값인 0이 선택됩니다.",
            "결과적으로 pivot 값의 위치가 그대로 변경되지 않으며 분할이 이루어지지 않습니다.",
            "오른쪽 부분만 남는 형태로 분할이 이루어집니다.",
            "이 과정을 반복하게 되면 매번 오른쪽 데이터만 남기 때문에 전체 시간 복잡도가 O(n^2)이 됩니다.",
            "이러한 퀵 정렬은 N^2 시간 복잡도가 나올 수 있기 때문에 이 점을 반드시 유의할 필요가 있습니다.",
            "대부분의 프로그래밍 언어에서 표준 정렬 라이브러리는 최악의 경우에도 O(n log n)을 보장합니다.",
            "첫 번째 원소를 pivot으로 설정하는 방식으로 퀵 정렬을 직접 구현하면 최악의 경우에 O(n^2)이 될 수 있습니다.",
            "표준 라이브러리를 이용하는 경우에는 기본적으로 O(n log n)을 보장합니다.",
            "퀵 정렬을 파이썬으로 구현한 예시는 다음과 같습니다."
        ],
        "topic": "삽입 정렬 (Insertion Sort) - 자바 구현"
    },
    {
        "code_start_timestamp": 1410.0,
        "code_end_timestamp": 1530.0,
        "code_text": "array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8\nlef quick_sort(array, start, end)\nif start >= end:\nreturn\npivot = start\nleft = start +1\nright = end\nwhile(left <= right):\nwhile(left <= end and array[left] <= array[pivot]):\nleft += 1\nwhile(right > start and array[right] >= array[pivot]):\nright -= 1\nif(left > right):           ?\narray[right], array[pivot] = array[pivot], array[right]\nelse:                            g\narray[left], array[right] = array[right], array[left]\nquick_sort(array, start, right - 1)\nquick_sort(array, right + 1, end)\nwick_sort(array, 0, len(array) - 1)\n\f",
        "related_speech_texts": [
            " 자, 그래서 이러한 퀵 정렬을 파이선으로 구현한 건 다한 것 같습니다.",
            " 자, 이렇게 총 10개의 데이터가 존재하는 걸 확인할 수 있고요.",
            " 이제 퀵 정렬을 수행할 때 현재 정렬을 위한 데이터의 범위에",
            " 오직 하나의 데이터만 포함되어 있다면",
            " 즉 원소가 한계인 경우에는 종류할 수 있도록 만들어주고요.",
            " 그렇지 않고, 정열하고자 하는 데이터가 여러계인 경우에는",
            " 먼저 첫 번째 원소를 비버스 값으로 설정합니다.",
            " 첫 번째 원소를 제외하고 오른쪽 원소 중에서",
            " 가장 왼쪽을 left, 가장 오른쪽을 right으로 설정하는 걸 확인할 수 있습니다.",
            " 자, 그래서 엇갈릴 때까지 반복을 하는 겁니다.",
            " left가 가를 끼고 있는 그 인덕스 보다",
            " 이 right의 가를 끼고 있는 인덕스의 값이 작다면",
            " 엇갈린 것이라고 판단할 수 있기 때문에",
            " 그때 반복문을 탈출할 수 있도록 가민 걸 확인할 수 있고요.",
            " 자, 그래서 반복할 때마다 항상 피부 보다",
            " 큰 데이터를 찾을 때까지",
            " 이 left를 일식 증가시켜줍니다.",
            " 또한 마찬가지로 피부 보다 작은 데이터를 찾을 때까지",
            " 이 오른쪽 위치에서 하나씩 왼쪽으로 이동하면서 탐색을 진행합니다.",
            " 즉 left는 항상 오른쪽으로 가고",
            " right은 항상 왼쪽으로 가기 때문에",
            " 이 과정 자체를 선영 탐색이라 볼 수 있겠죠.",
            " 그래서 결과적으로 left와 right 값을 확인해서",
            " 만약 위치가 엇갈렸다면",
            " 작은 데이터와 피부색 위치를 서로 바꿔시면 됩니다.",
            " 참고로 엇갈린 이유에는",
            " 이 right 변수가 가리키는 값이",
            " 더 작은 값이 되기 때문에",
            " 이 right of right과 right of 피부가 위치를 서로 바꿔시면 됩니다.",
            " 혹은 엇갈리지 않았다면",
            " 이 작은 데이터와 큰 데이터의 위치를 서로 바꿔시면 되겠습니다.",
            " 이제 분할 이후에 왼쪽 부분과",
            " 오른쪽 부분에 대해서",
            " 각각 다시 전열을 수행해서",
            " 이렇게 재기적으로 픽솔트를 호출하는 걸 확인할 수 있습니다.",
            " 그래서 이상적인 경우 이렇게 분할이 이루어질 때",
            " 이 왼쪽과 오른쪽이 서로 균형이 있게",
            " 분할이 이루어져서 빠르게 동작할 것을 기대할 수 있습니다.",
            " 그래서 이러한 함수를 이용해서",
            " 실제로 킥 정렬을 수행한 결과는",
            " 다음과 같이 성공적으로",
            " 오른차선으로 전열이 수행된 결과가 나오는 걸 확인할 수 있습니다.",
            " 마찬가지로 C++에서도 동일한 로직을 이용해서"
        ],
        "topic": "퀵 정렬 (Quick Sort) - 파이썬 구현"
    },
    {
        "code_start_timestamp": 1530.0,
        "code_end_timestamp": 1566.6666666666667,
        "code_text": "#include <bits/stdc++.h>\nusing namespace std;\nint n = 10;\nint target[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\nint main(void) {\n    for (int i = 1; i < n; i++) {\n        for (int j = i; j > 0; j--) {\n            if (target[j] < target[j - 1]) {\n                swap(target[j], target[j - 1]);\n            } else break;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cout << target[i] << ' ';\n    }\n    return 0;\n}\n",
        "related_speech_texts": [
            " 마찬가지로 C++에서도 동일한 로직을 이용해서 코드를 구현할 수 있는데요.",
            " 이렇게 문법만 다르고 파이썬 코드와 정확히 동일한 로직을 이용해서 구현되어 있는 걸 확인할 수 있습니다.",
            " 이렇게 두 번째 원소부터 마지막 원소까지 각 원소는 매번 더 이상 이동할 수 없을 때까지 그 왼쪽 데이터와 위치를 바꿔가면서 왼쪽으로 이동시켜주면 되는 겁니다.",
            " 그래서 이처럼 삽입 정렬까지 작성할 수가 있습니다.",
            " 마찬가지로 실행 결과는 동일하고요.",
            " 이어서 자바로 구현한 삽입 정렬은 바로 다음과 같습니다."
        ],
        "topic": "삽입 정렬 (Insertion Sort) - C++"
    },
    {
        "code_start_timestamp": 1566.6666666666667,
        "code_end_timestamp": 1570.0,
        "code_text": "public class Main {\n    public static void quickSort(int[] arr, int start, int end) {\n        if (start >= end) return;\n        int pivot = start;\n        int left = start + 1;\n        int right = end;\n        while (left <= right) {\n            while (left <= end && arr[left] <= arr[pivot]) left++;\n            while (right > start && arr[right] >= arr[pivot]) right--;\n            if (left > right) {\n                int temp = arr[pivot];\n                arr[pivot] = arr[right];\n                arr[right] = temp;\n            } else {\n                int temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n            }\n        }\n        quickSort(arr, start, right - 1);\n        quickSort(arr, right + 1, end);\n    }\n}\n",
        "related_speech_texts": [
            " 마찬가지로 자바에서도 동일한 로직으로 작성된 걸 확인할 수 있는데요.",
            " 이처럼 하나의 배열을 매개변수로 받아서",
            " 첫 번째 원소를 피벗으로 설정한 뒤에",
            " 왼쪽에서부터는 피벗보다 큰 데이터를 찾을 때까지 반복하고",
            " 오른쪽에서부터는 피벗보다 작은 데이터를 찾을 때까지 반복하는 걸 확인할 수 있습니다.",
            " 그래서 마찬가지로 엇갈렸다면 작은 데이터와 피벗의 위치를 서로 바꿔주고",
            " 엇갈리지 않았다면 작은 데이터와 큰 데이터의 위치를 바꿔주는 걸 확인할 수 있습니다.",
            " 이제 분할 이후에 왼쪽 부분과 오른쪽 부분에 대해서 각각 다시 퀵 정렬을 재귀적으로 호출하는 걸 확인할 수 있습니다.",
            " 그래서 이상적인 경우 이렇게 분할이 이루어질 때 왼쪽과 오른쪽이 균형 있게 분할이 이루어져서 빠르게 동작할 것을 기대할 수 있습니다.",
            " 그래서 이러한 함수를 이용해서 실제로 퀵 정렬을 수행한 결과는 다음과 같이 성공적으로 오름차순으로 정렬이 수행된 결과가 나오는 걸 확인할 수 있습니다.",
            " 마찬가지로 C++에서도 동일한 로직을 이용해서"
        ],
        "topic": "퀵 정렬 (Quick Sort) - Java"
    },
    {
        "code_start_timestamp": 1570.0,
        "code_end_timestamp": 1596.6666666666667,
        "code_text": "public static void main(String[] args) {\n    int n = 10;\n    int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        System.out.print(arr[i] + \" \");\n    }\n}\n",
        "related_speech_texts": [
            " 마찬가지로 C++에서도 동일한 로직을 이용해서 퀵 정렬을 작성할 수 있는데요.",
            " 이때 이 배열에 대한 정보는 포인터 형태로 매개 변수로 들어가 있는 걸 확인할 수 있고요.",
            " 마찬가지로 첫 번째 데이터를 피벗으로 설정하고 이어서 left와 right 값을 설정해 준 뒤에",
            " left는 항상 오른쪽으로 이동하면서 피벗 값보다 큰 값을 찾고",
            " right는 오른쪽에서 왼쪽으로 감소하면서 피벗 값보다 작은 데이터를 찾는 걸 확인할 수 있습니다.",
            " 그래서 엇갈렸을 때와 그렇지 않았을 때에 대해 처리한 결과적으로 분할이 이루어졌기 때문에",
            " 다시 왼쪽 범위와 오른쪽 범위에 대해서 퀵 정렬을 재귀적으로 호출하는 걸 확인할 수 있습니다.",
            " Java 또한 마찬가지의 로직으로 작성된 걸 확인할 수 있는데요."
        ],
        "topic": "퀵 정렬 (Quick Sort) - Java main function"
    },
    {
        "code_start_timestamp": 1893.3333333333333,
        "code_end_timestamp": 1954.3333333333333,
        "code_text": "def counting_sort(arr):\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for i in arr:\n        count[i] += 1\n    sorted_arr = []\n    for i, cnt in enumerate(count):\n        sorted_arr.extend([i] * cnt)\n    return sorted_arr\n\narray = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]\nprint(counting_sort(array))\n",
        "related_speech_texts": [
            " 이러한 개수 정렬을 파이썬을 이용해서 구현한 코드는 다음과 같습니다.",
            " 이처럼 총 15개의 데이터가 리스트에 담겨 있는 형태로 초기화할 수 있고요.",
            " 이제 모든 범위를 포함하는 크기로 리스트를 만듭니다. 이때 모든 값은 0으로 초기화할 수 있도록 하구요.",
            " 그래서 현재 데이터는 0부터 가장 큰 값인 9까지 구성되어 있기 때문에 9에 1을 더한 값인 10만큼의 크기를 가지는 하나의 Count 배열을 만듭니다.",
            " 이제 이어서 데이터를 하나씩 확인하면서 그 데이터에 해당하는 인덱스의 값을 1씩 증가시키는 걸 확인할 수 있습니다.",
            " 그래서 각 데이터가 몇 번씩 등장했는지를 이 Count 배열에 모두 기록한 뒤에 리스트의 기록된 정렬 정보를 실제로 확인하면서 정렬을 수행한 결과를 출력할 수 있는데요.",
            " 자 이처럼 인덱스 0부터 9까지 차례대로 확인하면서 각 인덱스에 해당하는 그 간만큼 반복적으로 인덱스 값을 출력하도록 만들면 전체 데이터에 대해서 정렬 수행 결과가 나오게 됩니다.",
            " C++ 또한 마찬가지의 로직으로 개수 정렬을 구현할 수 있는데요."
        ],
        "topic": "계수 정렬 (Counting Sort) - Python"
    },
    {
        "code_start_timestamp": 1954.3333333333333,
        "code_end_timestamp": 1994.6666666666667,
        "code_text": "#include <bits/stdc++.h>\n#define MAX_VALUE 9\nusing namespace std;\nint n = 15;\nint arr[15] = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};\nint cnt[MAX_VALUE + 1];\nint main(void) {\n    for (int i = 0; i < n; i++) {\n        cnt[arr[i]] += 1;\n    }\n    for (int i = 0; i <= MAX_VALUE; i++) {\n        for (int j = 0; j < cnt[i]; j++) {\n            cout << i << \" \";\n        }\n    }\n    return 0;\n}\n",
        "related_speech_texts": [
            " C++ 또한 마찬가지의 로직으로 개수 정렬을 구현할 수 있는데요.",
            " 마찬가지로 가장 큰 데이터가 9라고 가정하고 가장 작은 데이터가 0이라고 했을 때 모든 범위를 포함하는 크기의 배열을 만들어주고요.",
            " 마찬가지로 각 데이터를 하나씩 확인하면서 각 데이터에 해당하는 인덱스의 값을 증가시키도록 만들고 모든 데이터의 개수를 카운트했을 때 결과적으로 배열에 기록되어 있는 정렬 정보를 확인하면서 각 데이터가 등장한 횟수만큼 그 인덱스를 차례대로 출력하도록 만들면 정렬 수행 결과가 나오게 됩니다.",
            " Java 또한 C++와 동일한 로직으로 작성되어 있는 걸 확인할 수 있습니다.",
            " 이러한 개수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N + K)입니다.",
            " 다시 한 번 코드를 확인해 보시면 이렇게 데이터의 개수만큼 하나씩 데이터를 확인하면서 카운트 값을 체크하기 때문에 이제 여기에서 O(N)이라고 할 수 있겠고요.",
            " 그다음에 이제 원소 중에서 가장 큰 값을 의미하는 K만큼 각 인덱스를 확인하며 그 인덱스에 기록되어 있는 개수만큼 출력을 수행하는 걸 확인할 수 있습니다.",
            " 다만 이렇게 안쪽에 있는 반복문은 전체 수행 횟수가 N이라고 할 수 있습니다.",
            " 그렇기 때문에 결과적으로 이 이중 반복문의 시간 복잡도는 O(N + K)입니다.",
            " 그래서 결과적으로 전체 소스 코드의 시간 복잡도는 단순히 O(N + K)라고 정리할 수 있습니다.",
            " 그렇기 때문에 시간 복잡도는 O(N + K)이고요.",
            " 공간 복잡도 또한 마찬가지로 정렬을 수행할 데이터의 개수 N 그리고 데이터 중에서 가장 큰 값만큼의 크기를 가진 이 K만큼의 공간이 필요합니다.",
            " 그래서 공간 복잡도 또한 마찬가지로 O(N + K)입니다.",
            " 그렇기 때문에 이러한 개수 정렬은 때에 따라서 심각한 비효율성을 처리할 수 있습니다.",
            " 예를 들어서 데이터가 단 두 개만 존재한다고 해 볼게요.",
            " 이렇게 0과 999,999가 있다고 했을 때 데이터는 단 두 개밖에 존재하지 않지만 우리는 총 1,000,000개만큼의 원소가 담길 수 있는 배열을 만들어야 합니다.",
            " 그렇기 때문에 데이터의 범위가 너무 크다면 이러한 개수 정렬을 사용하기가 어렵다는 점이 특징이고요.",
            " 개수 정렬이 효과적으로 사용될 수 있는 때는 바로 동일한 값을 가지는 데이터가 여러 개 등장할 때입니다.",
            " 대표적으로 학생들의 성적에 따라서 정렬을 할 때 성적의 경우 일반적으로 0부터 100까지로 범위가 좁혀지는 경우가 많습니다.",
            " 그렇기 때문에 각각의 점수에 따라서 해당 점수를 맞은 학생이 여러 명일 수 있기 때문에 이런 경우에는 데이터의 값 범위가 한정적이면서 정렬할 데이터가 많다는 점에서 개수 정렬이 효과적으로 사용될 수 있습니다."
        ],
        "topic": "계수 정렬 (Counting Sort) - C++"
    },
    {
        "code_start_timestamp": 2213.3333333333335,
        "code_end_timestamp": 2313.3333333333335,
        "code_text": "import random\nimport time\narray = [random.randint(1, 100) for _ in range(10000)]\nstart_time = time.time()\narray.sort()\nend_time = time.time()\nprint(\"기본 정렬 라이브러리 성능 측정: \", end_time - start_time)\n",
        "related_speech_texts": [
            " 추가적으로 선택 정렬과 기본 정렬 라이브러리의 수행 시간을 비교하는 코드를 가져왔습니다.",
            " 기본적인 선택 정렬과 표준 라이브러리의 수행 시간을 비교하면 다음과 같습니다.",
            " 먼저 정렬을 수행시킬 목적으로 랜덤한 만개의 데이터를 이용하겠습니다.",
            " 그래서 파이썬 라이브러리 중에서 이 랜덤 함수를 사용하겠습니다.",
            " 이 array 변수에 총 10,000개만큼의 데이터가 랜덤하게 1부터 100까지의 값으로 담길 수 있도록 하고요.",
            " 이제 수행 시간을 측정하기 위해서 이 start_time과 end_time 변수가 실제 알고리즘의 바깥쪽에 선언되어 있는 걸 확인할 수 있습니다.",
            " 우리가 앞서 다루었던 선택 정렬의 코드가 안쪽에 들어가 있는 걸 확인할 수 있고요.",
            " 그래서 선택 정렬을 수행한 결과를 출력하도록 만들려면 이렇게 끝 시간에서 시작 시간을 뺀 값을 출력하면 되겠죠.",
            " 그래서 약 35초 정도의 시간이 소요된 걸 확인할 수 있습니다.",
            " 물론 이러한 수행 시간 측정 결과는 여러분들이 이 코드를 실행하는 그 컴퓨팅 장치에 따라서 차이가 존재할 수 있다는 점 유의해주세요.",
            " 이어서 다시 배열을 무작위 데이터로 초기화할 수 있도록 합니다.",
            " 마찬가지로 다시 이렇게 1부터 100까지의 랜덤한 정수가 이 array에 담길 수 있도록 하고요.",
            " 이번에는 수행 시간을 측정할 때 파이썬에서 기본적으로 제공하는 표준 정렬 라이브러리를 그대로 사용할 수 있도록 했습니다.",
            " 파이썬의 경우 병합 정렬을 기반으로 하는 하이브리드 방식의 정렬 알고리즘을 사용하고 있기 때문에 최악의 경우에도 O(N log N)의 시간 복잡도를 보장합니다.",
            " 그래서 실제 수행 결과를 확인해 보시면 선택 정렬과 비교했을 때 1초보다도 훨씬 짧은, 상대적으로 훨씬 짧은 시간에 정렬을 수행하는 것을 확인할 수 있습니다."
        ],
        "topic": "기본 정렬 라이브러리 성능 측정"
    },
    {
        "code_start_timestamp": 2313.3333333333335,
        "code_end_timestamp": 2393.3333333333335,
        "code_text": "array = []\nfor _ in range(10000):\n    array.append(random.randint(1, 100))\nstart_time = time.time()\narray.sort()\nend_time = time.time()\nprint(\"기본 정렬 라이브러리 성능 측정: \", end_time - start_time)\n",
        "related_speech_texts": [
            " 기본적인 선택 정렬과 표준 라이브러리의 수행 시간을 비교하면 다음과 같습니다.",
            " 먼저 정렬을 수행시킬 목적으로 랜덤한 만개의 데이터를 이용하겠습니다.",
            " 그래서 파이썬 라이브러리 중에서 이 랜덤 함수를 사용하겠습니다.",
            " 이 array 변수에 총 10,000개만큼의 데이터가 랜덤하게 1부터 100까지의 값으로 담길 수 있도록 하고요.",
            " 이제 수행 시간을 측정하기 위해서 이 start_time과 end_time 변수가 실제 알고리즘의 바깥쪽에 선언되어 있는 걸 확인할 수 있습니다.",
            " 우리가 앞서 다루었던 선택 정렬의 코드가 안쪽에 들어가 있는 걸 확인할 수 있고요.",
            " 그래서 선택 정렬을 수행한 결과를 출력하도록 만들려면 이렇게 끝 시간에서 시작 시간을 뺀 값을 출력하면 되겠죠.",
            " 그래서 약 35초 정도의 시간이 소요된 걸 확인할 수 있습니다.",
            " 물론 이러한 수행 시간 측정 결과는 여러분들이 이 코드를 실행하는 그 컴퓨팅 장치에 따라서 차이가 존재할 수 있다는 점 유의해주세요.",
            " 이어서 다시 배열을 무작위 데이터로 초기화할 수 있도록 합니다.",
            " 마찬가지로 다시 이렇게 1부터 100까지의 랜덤한 정수가 이 array에 담길 수 있도록 하고요.",
            " 이번에는 수행 시간을 측정할 때 파이썬에서 기본적으로 제공하는 표준 정렬 라이브러리를 그대로 사용할 수 있도록 했습니다.",
            " 파이썬의 경우 병합 정렬을 기반으로 하는 하이브리드 방식의 정렬 알고리즘을 사용하고 있기 때문에 최악의 경우에도 O(N log N)의 시간 복잡도를 보장합니다.",
            " 그래서 실제 수행 결과를 확인해 보시면 선택 정렬과 비교했을 때 1초보다도 훨씬 짧은, 상대적으로 훨씬 짧은 시간에 정렬을 수행하는 것을 확인할 수 있습니다."
        ],
        "topic": "기본 정렬 라이브러리 성능 측정 - 파이썬"
    },
    {
        "code_start_timestamp": 2393.3333333333335,
        "code_end_timestamp": 2486.6666666666665,
        "code_text": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> a, b;\nbool compare(int x, int y) {\n    return x > y;\n}\nint main() {\n    cin >> n >> k;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n; i++) cin >> b[i];\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end(), compare);\n    for (int i = 0; i < k; i++) {\n        if (a[i] < b[i]) swap(a[i], b[i]);\n        else break;\n    }\n    int result = accumulate(a.begin(), a.end(), 0);\n    cout << result << endl;\n    return 0;\n}\n",
        "related_speech_texts": [
            " C++에서도 동일한 로직으로 코드를 작성할 수 있는데요.",
            " 이때 벡터 라이브러리를 이용해서 배열 A와 배열 B의 모든 원소를 담을 수 있습니다.",
            " 또한 내림차순 정렬을 위해서 별도로 compare라는 함수를 정의해서 원소의 값이 더 큰 경우에 높은 우선순위를 가지도록 만들어서 내림차순 정렬을 수행하도록 만들 수 있습니다.",
            " 그래서 이처럼 배열 A와 B의 모든 원소를 다 넣어준 뒤에 배열 A는 일반적인 오름차순 정렬을 수행하고 이 배열 B는 내림차순 정렬을 수행할 수 있도록 합니다.",
            " 그래서 각 인덱스마다 원소를 하나씩 확인하며 이 A의 원소가 B의 원소보다 작은 경우에만 두 원소를 서로 교체하도록 만듭니다.",
            " 그래서 결과적으로 배열 A에 담겨 있는 모든 원소의 합을 출력하도록 만드는 것을 확인할 수 있습니다."
        ],
        "topic": "두 배열의 원소 교체 - C++"
    },
    {
        "code_start_timestamp": 2486.6666666666665,
        "code_end_timestamp": 2523.3333333333335,
        "code_text": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na.sort()\nb.sort(reverse=True)\nfor i in range(k):\n    if a[i] < b[i]:\n        a[i], b[i] = b[i], a[i]\n    else:\n        break\nprint(sum(a))\n",
        "related_speech_texts": [
            " 파이썬을 이용한 정답 코드 예제는 다음과 같습니다.",
            " 이렇게 먼저 n과 k를 입력을 받고 배열 a와 배열 b에 대해선 모두 입력을 받습니다.",
            " 배열 a는 오름차순으로 정렬을 수행하고 배열 b는 내림차순으로 정렬을 수행합니다.",
            " 정렬 함수를 호출할 때 이 reverse 속성의 값으로 True 값을 넣어주게 되면 정렬을 수행할 때 내림차순으로 수행합니다.",
            " 그래서 결과적으로 첫 번째 인덱스부터 차례대로 인덱스를 확인하며 두 배열의 원소를 최대 k번 비교하면 됩니다.",
            " 그래서 매번 이 a의 원소가 b의 원소보다 작은 경우에는 두 원소를 교체해서 배열 a의 모든 원소의 합이 더 커지도록 만들면 되고요.",
            " 이제 그렇지 않고 a의 원소가 b의 원소보다 크거나 같은 경우에는 더 이상 배열 a의 원소의 합을 크게 만들 수 없기 때문에 그 경우에는 반복문을 탈출하면 됩니다.",
            " 그래서 결과적으로 배열 a의 모든 원소의 합을 출력하도록 만들면 정답 판정을 받을 수 있습니다."
        ],
        "topic": "두 배열의 원소 교체 - 파이썬"
    },
    {
        "code_start_timestamp": 2523.3333333333335,
        "code_end_timestamp": 2556.6666666666665,
        "code_text": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> a, b;\nbool compare(int x, int y) {\n    return x > y;\n}\nint main() {\n    cin >> n >> k;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n; i++) cin >> b[i];\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end(), compare);\n    for (int i = 0; i < k; i++) {\n        if (a[i] < b[i]) swap(a[i], b[i]);\n        else break;\n    }\n    int result = accumulate(a.begin(), a.end(), 0);\n    cout << result << endl;\n    return 0;\n}\n",
        "related_speech_texts": [
            " C++에서도 동일한 로직으로 코드를 작성할 수 있는데요.",
            " 이때 벡터 라이브러리를 이용해서 배열 A와 배열 B의 모든 원소를 담을 수 있습니다.",
            " 또한 내림차순 정렬을 위해서 별도로 compare라는 함수를 정의해서 원소의 값이 더 큰 경우에 높은 우선순위를 가지도록 만들어서 내림차순 정렬을 수행하도록 만들 수 있습니다.",
            " 그래서 이처럼 배열 A와 B의 모든 원소를 다 넣어준 뒤에 배열 A는 일반적인 오름차순 정렬을 수행하고 이 배열 B는 내림차순 정렬을 수행할 수 있도록 합니다.",
            " 그래서 각 인덱스마다 원소를 하나씩 확인하며 이 A의 원소가 B의 원소보다 작은 경우에만 두 원소를 서로 교체하도록 만듭니다.",
            " 그래서 결과적으로 배열 A에 담겨 있는 모든 원소의 합을 출력하도록 만드는 것을 확인할 수 있습니다."
        ],
        "topic": "두 배열의 원소 교체 - C++"
    },
    {
        "code_start_timestamp": 2556.6666666666665,
        "code_end_timestamp": 2570.0,
        "code_text": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        Integer[] a = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextInt();\n        }\n        Arrays.sort(a);\n        Arrays.sort(b, Collections.reverseOrder());\n        for (int i = 0; i < k; i++) {\n            if (a[i] < b[i]) {\n                int temp = a[i];\n                a[i] = b[i];\n                b[i] = temp;\n            } else break;\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            result += a[i];\n        }\n        System.out.println(result);\n    }\n}\n",
        "related_speech_texts": [
            " 마찬가지로 자바에서도 동일한 로직으로 코드를 작성할 수 있는데요.",
            " 이처럼 배열 A와 배열 B의 모든 원소를 입력받은 뒤에 어레이스의 sort 메서드를 이용해서 배열 A와 B의 원소들을 각각 정렬할 수 있도록 합니다.",
            " 이때 배열 B는 내림차순 정렬을 수행하기 위해 이 컬렉션즈 라이브러리의 reverseOrder 메서드를 인자로 넣어줄 수 있도록 합니다.",
            " 이어서 정렬을 수행한 배열 A와 B에 대해서 각 인덱스를 앞에서부터 하나씩 확인하며 A의 원소가 B의 원소보다 작은 경우에만 원소를 교체하도록 만드는 걸 확인할 수 있습니다.",
            " 이처럼 C++ 코드와 동일한 로직으로 코드가 작성되어 있는 걸 확인할 수 있습니다.",
            " 이상으로 두 배열의 원소 교체 문제까지 풀어보았습니다."
        ],
        "topic": "두 배열의 원소 교체 - Java"
    },
    {
        "code_start_timestamp": 2570.0,
        "code_end_timestamp": 2580.0,
        "code_text": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        Integer[] a = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextInt();\n        }\n        Arrays.sort(a);\n        Arrays.sort(b, Collections.reverseOrder());\n        for (int i = 0; i < k; i++) {\n            if (a[i] < b[i]) {\n                int temp = a[i];\n                a[i] = b[i];\n                b[i] = temp;\n            } else break;\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            result += a[i];\n        }\n        System.out.println(result);\n    }\n}\n",
        "related_speech_texts": [
            " 마찬가지로 자바에서도 동일한 로직으로 코드를 작성할 수 있는데요.",
            " 이처럼 배열 A와 배열 B의 모든 원소를 입력받은 뒤에 어레이스의 sort 메서드를 이용해서 배열 A와 B의 원소들을 각각 정렬할 수 있도록 합니다.",
            " 이때 배열 B는 내림차순 정렬을 수행하기 위해 이 컬렉션즈 라이브러리의 reverseOrder 메서드를 인자로 넣어줄 수 있도록 합니다.",
            " 이어서 정렬을 수행한 배열 A와 B에 대해서 각 인덱스를 앞에서부터 하나씩 확인하며 A의 원소가 B의 원소보다 작은 경우에만 원소를 교체하도록 만드는 걸 확인할 수 있습니다.",
            " 이처럼 C++ 코드와 동일한 로직으로 코드가 작성되어 있는 걸 확인할 수 있습니다.",
            " 이상으로 두 배열의 원소 교체 문제까지 풀어보았습니다."
        ],
        "topic": "두 배열의 원소 교체 - Java"
    }
]